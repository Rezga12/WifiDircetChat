# დეზაინ  დოკუმენტი  #

პროექტი გაკეთებულია MVP პატერნით (შეძლებისდაგვარად).

### მოდელი  ###
მოდელში იგულისხმება რა შევინახეთ room-ს ბიბლიოთეკის მონაცემთა სტრუქტურაში და როგორ:

იდეაში გვაქვს ორი თეიბლი:
```java
@Entity(tableName = "Devices")
public class Device {
    @PrimaryKey
    public String mac;
	public String name;
}

public class Message {
	@PrimaryKey(autoGenerate = true)
    public long id;
	public String peerAddress;
    public String message;
	public boolean isOwnMessage;
	public Date sendTime;
}



```
გვაქვს ორი ენთითი კლასი. დევაისი ინახავს მაკს და სახელს მარტივია იდეაში. onConflictStrategy აქვს replace, იმ შემთხვევაში თუ ახალი სახელით შემოვიდა ის ტელეფონი.

მესიჯების ცხრილში ვინახავთ ბულეანს ამ ტელეფონისაა ვინც ბაზას ინახავს თუ მეორესი, ანუ ვისთანაც მიმოწერა აქვს. და დანარჩენი სტანდარტული ფილდები.

Querry-ებს რაც შეეხება MessageDao.java ში გვიწერია. თითქმის ყველაფერი სტანდარტულია, ერთადერთი ჯოინით არის წამოღება მოწემული დევაისის რამდენი მესიჯი არის მიმოწერაში და ბოლოს მოსული მესიჯის დრო, რომ პირობის მიხედვით გამოტანილიყო მერე.

MessageRepository კლასი არის ბაზასთან დასაკავშირებლად. ასინქრონული ტასკები აქ მაქვს გაწერილი. და public მეთოდებს გადაეცემათ მაგალითად Message ობიექტი და მერე ასინქრონული ტასკი ეშვება და ბაზაში ჩასწერს.
წამოღებისას, გადმოვცემ Handler მეთოდს. რომელიც განსაზღვრევს თუ რა გაუკეთდეს წამოღებულ დატას. უმეტესწილად პრეზენტერში გამოიძახება ეს მეთოდი და პრეზენტერი ეუბნება იმ წამოღებულ დატას რა უქნას. MessageRepository კლასსში არის 121-ე ხაზზე დაახლოებით.

კიდევ აღსანიშნავია ის, რომ RoomDatabase ობიექტი სინგლტონად მაქვს, რადგან ბევრი ინსთანსი არ იქნება საჭირო ალბათ ამის.


### ვიუები   ###

ყველა გვერს აქვს თავისი პრეზენტერი. სულ გვაქვს 4 ნაირი გვერდი და შესაბამისად 4 პრეზენტერი.
ესენია: * HistoryFragment
		* ChatActivity
		* ArchivedChatActivity
		* ListPeerFragment

ანუ რაკი ნავიგაციით უნდა გაგვეკეთებინა, რომელიც ანდროიდ სტუდიოს მოყვება, ფრაგმენტებზე გადადის ეს ნავიგაცია. ისტორიის გვერდი არის ჩამონათვალი უწინ რომელ ტელეფონებთანაც ქონდა მიწერ მოწერები. ხოლო ListPeersFragment არის იმ დევაისების ჩამონათვალი, რომლებსაც შეუძლია დაუკავშირდეს. ანუ მსგავსი გვერდებია ეს ორი. და როცა უშუალოდ ჩატის დასათვალიერებლად გადადიხარ უკვე ახალი აქთივითი იხსნება. 

#### ისტორიის გვერდი  ####

აქ გვაქვს ისტორიის ჩამონათვალი, რომელიც მოტავსებულია კარგად ნაცნობ RecyclerView-ში. რაკი MVP-თი ვაკეთებდით. RecyclerViewAdapter ინახავს უშუალოდ პრეზენტერს და აღარ ინახავს მონაცემების ლისთს როგორც ადრე იყო ხოლმე და პრეზენტერს აქვს ისეთი მეთოდები, როგორიცაა ლისთის ზომის დაბრუნება და ვიუს დაბაინდებისას მონაცემთა დასეტვა.
პრეზენტერს აქვს onBIndViewHOlderAtPosition მეთოდი, რომელსაც გადაეცემა პოზიცია ლისტის ელემენტის, და ინტერფეისი, რომელსაც აქვს ვიუჰოლდერის ელემენტების დასეტვა და რომელსაც ვიუჰოლდერი აიმპლემენტირებს. ანუ პრეზენტერს გადავცემთ ინტერფეისს და მერე პრეზენტერს დატა ამოაქვს და ამ მეთოდებით სეტავს. ანუ პირდაპირ ვიუჰოლდერზე არ აქვს პრეზენტერს წვდომა ამ ვიუჰოლდერის ინტერფეისზე აქვს.

სწორედ აქ ვიყენებ დაჯოინებას ბაზაში რომ დევაისის სახელთან ერთად წამოვიღო ბოლო მინაწერის დრო და მინაწერების რაოდენობა.

როდესაც ვაჭერთ რომელიმე სელლს ამ ისტორიის გვერდზე იხსნება ახალი აქთივითი, სადაც უკვე გამოტანილია ჩატის გვერდი და მიწერ-მოწერები ამ დევაისთან. ასევე მშვენიერი ანიმაციით მესიჯზე დაჭერისას მესიჯი მაღლა ადის და დრო იხატება ქვემოთ. უკან დაბრუნების ღილაკით ვბრუნდებით უკან. ეს ჩატის გვერდიც არის recyclerView.და ზუსტად იგივე პრინციპით მუშაობს როგორც წეღან ავღწერე. საკუთარი და მეორე ადამიანის მესიჯების გასარჩევად გამოვიყენეთ ორი layout-ი და იმის მიხედვით თუ ვისი მესიჯია ლეიაუთები სელებისათვის იცვლება. ასევე თუ დავაკვირდებით ჩატის დიზაინი არის მშვენიერი :).

წაშლას რაც შეეხება როგორც პირობაში იყო მოთხოვნილი ისეარის. გამოყენებული გვაქვს DialogFragment და წაშლაზე დაწერისას გეკითხება ნამდვილად გინდა თუარა წაშლა და შემდეგ ეშვება delete query ბაზაში. და შემდეგ notifyDataSetChanged და ლისტიც გაქრება ვიზუალურად. ცალკეულ სელზე ლონგკლიკითაც მსგავსი რამ ხდება. DialogFragment იყენებს ცალკე თავის layouts სადაც როგორ დიზაინსაც გინდა ისეთს მისცემ. და ჩვეულებრივი ფრაგმენტივითაა.

### ჩატის გვერდი  ###

ჩატის გვერდისათვის გამოყენებულია რამდენიმე ინტერაქტორ კლასი რომლებიც შეიცავენ WidiP2p ბიბლიოთეკის ნაწილს, და გარეთ პრეზენტერი მათი საშუალებით ამუშავებს თავის ფუნქციონალს.

ჯერ დავიწყოთ AvailablePeersFragment-ით სადაც გვჭირდება რომ გამოვიტანოთ რომელ დევაისებს შეგვიძლია დავუკავშირდეთ.
ამ ფუნქციონალის შევქმენით P2pPeerListInteractor კლასი, რომელსაც აქვს requestPeers მეთოდი, რომელსაც WifiP2p სერვისების საშუალებით მოაქვს ეს სია და იძახებს პრეზენტერის მეთოდს რომელიც ანახლებს ამ ლისტს. ამ მეთოდს იძახებს ბროადქასთ რესივერის კლასი MyBroadcastReciever onRecieve-ში. ანუ როდესაც მოხდება ცვლილება დევაისების ლისტში ხდება ამ ლისტის განახლება ვიუში. ანუ როდესაც ინმე დაემატება ან გამოაკლდება peer ist-ს შესაბამისი ბროადქასთი მისდის ტელეფონს და ამ ბროადკასტს იჭერს ჩვენი რესივერი.

#### დაკავშირება  ####
როდესაც ხელმისაწვდომი დევაისებიდან რომელიმეს ვაჭერთ იწყება დაკავშირება. ამ დროს მუშაობს P2pConnector კლასი, რომელიც იძახებს p2pMannager-ის connect მეთოდს და დევაისი მაკ მისამართის საშუალებით ახდენს კავშირს. როდესაც მეორე დევაისსაც მისდის კავშირის დამყარების ბროადკასტი, ხდება გადასხვლა უკვე ჩატის გვერდზე. ანუ სანამ წარმატებულად არ მოხდება დაკავშირება იქამდე ლოადინგი ხდება და ტრიალებს ის რაღაც. დაკავშირების შემდეგ ის დევაისი, რომელიც არის group owner-ი ხსნის სერვერს სოკეტს და ელოდება accept-ზე კლიენტს. როდესაც ორივე სოკეტი დაუკავირდება ერთმანეთს მაშინ ბაზიდან გადმოიწერება ძველი ჩატი და უკვე შესაძლებელი ხდება მიწერმოწერა.

სოკეტებიდან ინფორმაციის ამოსაღებად ვიყენებთ ასინქრონულ ტასკებს. 2 ტასკს კერძოდ. ერთი არის გაგზავნისთვის მეორე მიღებისთვის. მიღებისვის არსებული ტასკი არის while ციკლში მანამ, სანამ არ გაწყდება ქონექშენი სოკეტებს შორის და გაჩერებულია recieve()-ზე. როდესაც მიიღებს დატას, ეს ნიშნავს, რომ მესიჯი მისწერეს და  publishProgress მეთოდის საშუალებით ხდება მიღებული ინფორმაციის ბაზაში ჩამატება და შემდგომ ჩატის RecyclerVIew-ს დარეფრეშებით ამ მესიჯის გამოჩენა
გასაგზავნი ასინქრონული ტასკი ეშვება მაშინ, როდესაც მომხმარებელი გაგზავნის იკონს აჭერს. სოკეტში უშვებს EditText-ში არსებულ ინფორმაციას ეს ტასკი. და თან ბაზაში ამატებს როგორც გაგზავნილ მესიჯს.
როდესაც ერთი დევაისი წყვეტს კავშირს, ანუ გამოდის ჩატის გვერდიდან კავშირი მეორესთანაც წყდება ავტომატურად. ჩატის აქთივითის ჩაკეტვით ან ეკრანის ლოქით არ წყდება ქონექშენი.

ბაზაში საუბრები შენახულია თითოეულ დევაისთან ცალცალკე. თუ რომელიმე დევაისს მეორედ უკავშირდება ძველი საუბარი გრძელდება. სახელი რომ შეიცვალოს რომელიმე დევაისმა მაშინ ბაზაშიც შეეცვლება სახელი რადგან მაკმისამართზეარის დამოკიდებული დევაისის იდენტობა.



